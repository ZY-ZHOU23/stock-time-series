---
title: "Stock Forecasting Project"
output: 
  pdf_document:
    toc: true
---

\newpage
# Libraries

```{r message=FALSE}
library(tidyverse)
library(lubridate)
library(quantmod)
library(tseries)
library(forecast)
```

# Data Gathering

## User Inputs (Stock and Date)

```{r}
symbol <- "AAPL"
start_date <- as.Date("2022-01-01")
end_date <- Sys.Date()
```

## Stock Data Collection

```{r}
getSymbols(symbol, 
           src  = "yahoo", 
           from = start_date, 
           to   = end_date,
           auto.assign = TRUE)

stock_data <- get(symbol)

# head(stock_data)
```

# Data Exploration & Feature Engineering

## EDA

```{r}
# Convert time-series data (xts object) to a regular tibble
df_stock <- tibble(
  date     = index(stock_data),
  open     = as.numeric(stock_data[, paste0(symbol, ".Open")]),
  high     = as.numeric(stock_data[, paste0(symbol, ".High")]),
  low      = as.numeric(stock_data[, paste0(symbol, ".Low")]),
  close    = as.numeric(stock_data[, paste0(symbol, ".Close")]),
  volume   = as.numeric(stock_data[, paste0(symbol, ".Volume")]),
  adjusted = as.numeric(stock_data[, paste0(symbol, ".Adjusted")])
)

glimpse(df_stock)
summary(df_stock)

# Plot Adjusted Closing Price over time with a dynamic title
ggplot(df_stock, aes(x = date, y = adjusted)) +
  geom_line() +
  labs(title = paste(symbol, "Adjusted Closing Price"),
       x = "Date",
       y = "Adjusted Price") +
  theme_minimal()

```

```{r}
# Check if there is any NA (rare to have NA)
df_stock %>%
  summarize(across(everything(), ~ sum(is.na(.)))) 
```

## Feature Engineering

### Add new variables

```{r}
# Calculate Bollinger Bands using high, low, and close
bb <- BBands(HLC = df_stock %>% select(high, low, close),
             n = 20, maType = "SMA", sd = 2)

# Calculate MACD based on the adjusted closing price
macd_values <- MACD(df_stock$adjusted, nFast = 12, nSlow = 26, nSig = 9)

# Add all new variables
df_stock <- df_stock %>%
  arrange(date) %>%
  mutate(
    daily_return = (adjusted - lag(adjusted)) / lag(adjusted) * 100,
    lag1_close = lag(adjusted, 1),
    lag2_close = lag(adjusted, 2),
    ma20 = rollmean(adjusted, k = 20, fill = NA, align = "right"),
    ma50 = rollmean(adjusted, k = 50, fill = NA, align = "right"),
    rsi14 = RSI(adjusted, n = 14),
    bb_dn   = bb[, "dn"],
    bb_mavg = bb[, "mavg"],
    bb_up   = bb[, "up"],
    bb_pctB = bb[, "pctB"],
    macd    = macd_values[, "macd"],
    macdSig = macd_values[, "signal"],
    rolling_sd_20 = rollapply(daily_return, width = 20, 
                              FUN = sd, fill = NA, align = "right"),
    wday = wday(date, label = TRUE),
    sin_wday = sin(2 * pi * wday(date) / 7),
    cos_wday = cos(2 * pi * wday(date) / 7)
  )

```

### Visualize new variables

```{r warning=FALSE}
# 14-Day RSI
ggplot(df_stock, aes(x = date, y = rsi14)) +
  geom_line() +
  labs(title = "14-Day RSI", x = "Date", y = "RSI") +
  theme_minimal()

# MAs
df_stock_long <- df_stock %>%
  select(date, adjusted, ma20, ma50) %>%
  pivot_longer(cols = c("adjusted", "ma20", "ma50"), 
               names_to = "variable", values_to = "value")

ggplot(df_stock_long, aes(x = date, y = value, color = variable)) +
  geom_line() +
  labs(title = paste(symbol, "Adjusted Price vs MAs"),
       x = "Date", y = "Value", color = "Series") +
  theme_minimal()

# Bollinger Bands
ggplot(df_stock, aes(x = date)) +
  geom_line(aes(y = close), color = "blue") +
  geom_line(aes(y = bb_dn), color = "red", linetype = "dashed") +
  geom_line(aes(y = bb_up), color = "red", linetype = "dashed") +
  labs(title = "Bollinger Bands", y = "Price") +
  theme_minimal()

# 20-day Rolling Std Dev of Daily Returns
ggplot(df_stock, aes(x = date, y = rolling_sd_20)) +
  geom_line() +
  labs(title = "20-day Rolling Std Dev of Daily Returns",
       x = "Date", y = "Rolling SD (%)") +
  theme_minimal()
```

### Other tests and analysis
```{r}
# Correlation Matrix of Numeric Features
df_numerics <- df_stock %>%
  select(where(is.numeric)) %>%
  drop_na()  # Remove rows with NA for accurate correlation

GGally::ggcorr(df_numerics, 
               method = c("pairwise.complete.obs", "pearson"),
               label  = TRUE) +
  ggtitle("Correlation Matrix of Numeric Features")

```

```{r}
# Stationarity Tests: Adjusted Price and Daily Returns
adf_result <- adf.test(df_stock$adjusted, alternative = "stationary")
print(adf_result)

adf_returns <- adf.test(na.omit(df_stock$daily_return), alternative = "stationary")
print(adf_returns)

```

Findings on Stationarity: 
- The adjusted price is non-stationary, which is expected because stock prices tend to follow a random walk.
- The daily returns are stationary, which is typical for financial return series since they fluctuate around a constant mean.


# Model 1: ARIMA with Exogenous Regressors (ARIMAX)
## Preperation for model 1
### Convert to weekly data
```{r}
# Change to weekly data for less computation
df_weekly <- df_stock %>%
  mutate(week = floor_date(date, unit = "week", week_start = 1)) %>%
  group_by(week) %>%
  summarise(
    open = first(open),
    high = max(high, na.rm = TRUE),
    low = min(low, na.rm = TRUE),
    close = last(close),
    volume = sum(volume, na.rm = TRUE),
    first_adj = first(adjusted),                      
    adjusted = last(adjusted),                       
    weekly_return = (last(adjusted) / first_adj - 1) * 100,
    ma20 = last(ma20),
    ma50 = last(ma50),
    rsi14 = last(rsi14),
    bb_dn = last(bb_dn),
    bb_mavg = last(bb_mavg),
    bb_up = last(bb_up),
    bb_pctB = last(bb_pctB),
    macd = last(macd),
    macdSig = last(macdSig),
    rolling_sd_20 = last(rolling_sd_20),
    wday = last(wday),
    sin_wday = last(sin_wday),
    cos_wday = last(cos_wday)
  ) %>%
  ungroup() %>%
  select(-c(first_adj, wday))

head(df_weekly, 2)
```

```{r}
tsdisplay(df_weekly$adjusted)
tsdisplay(df_weekly$volume)
tsdisplay(df_weekly$rsi14)
tsdisplay(df_weekly$ma20)
tsdisplay(df_weekly$ma50)
```


### Train test split
```{r}
cutoff_date <- as.Date("2024-05-31")

train_data <- df_weekly %>%
  filter(week <= cutoff_date) %>%
  drop_na(adjusted, volume, rsi14, ma20, ma50)

test_data <- df_weekly %>%
  filter(week > cutoff_date) %>%
  drop_na(adjusted, volume, rsi14, ma20, ma50)
```

### Forecast exogenous variables
```{r}
# Define forecast function
forecast_exog <- function(train_df, test_df, var_name, freq = 52) {
  
  train_ts <- ts(train_df[[var_name]], frequency = freq)
  fit <- auto.arima(train_ts, stepwise = TRUE, approximation = TRUE)
  h <- nrow(test_df)
  fc <- forecast(fit, h = h)
  
  list(forecast_obj = fc,                     
       forecast = as.numeric(fc$mean),     
       AIC = AIC(fit),
       actual = ts(test_df[[var_name]], frequency = freq, 
                   start = c(1, length(train_df[[var_name]]) + 1)))
}


# Start forecast

exog_vars <- c("volume", "rsi14", "ma20", "ma50")
exog_perf <- tibble(variable = character(), 
                    MAPE = numeric(), 
                    MSE = numeric(), 
                    AIC = numeric())


exog_forecasts <- list()

for (var in exog_vars) {
  fc_result <- forecast_exog(train_data, test_data, var)
  exog_forecasts[[var]] <- fc_result$forecast 
  
  # Compute performance metrics
  actual_ts <- fc_result$actual
  mape_exog <- mean(abs(fc_result$forecast - actual_ts) / abs(actual_ts)) * 100
  mse_exog <- mean((fc_result$forecast - actual_ts)^2)
  
  exog_perf <- exog_perf %>%
    add_row(variable = var, MAPE = mape_exog, 
            MSE = mse_exog, AIC = fc_result$AIC)
  
  # Plot 
  print(
    autoplot(fc_result$forecast_obj) +
      autolayer(actual_ts, series = "Actual") +
      labs(title = paste(symbol, var, "Forecast"),
           x = "Time", y = var) +
      theme_minimal()
  )
}

exog_perf
```

## Build model 1
```{r}
train_ts <- ts(train_data$adjusted, frequency = 52)
test_ts <- ts(test_data$adjusted, frequency = 52, 
              start = c(1, length(train_data$adjusted) + 1))

xreg_train <- as.matrix(train_data %>% select(volume, rsi14, ma20, ma50))
xreg_test <- cbind(
  volume = exog_forecasts[["volume"]],
  rsi14 = exog_forecasts[["rsi14"]],
  ma20 = exog_forecasts[["ma20"]],
  ma50 = exog_forecasts[["ma50"]]
)

# Fit the model / forecast
model_arima <- auto.arima(train_ts, xreg = xreg_train)
summary(model_arima)

h <- nrow(test_data)
final_forecast_1 <- forecast(model_arima, xreg = xreg_test, h = h)

```

## Performance
```{r}
autoplot(final_forecast_1) +
  autolayer(test_ts, series = "Actual") +
  labs(title = paste(symbol, "ARIMAX Forecast with Forecasted Exogenous Variables"),
       x = "Time", y = "Adjusted Price") +
  theme_minimal()

# Calculate error metrics: MAPE and MSE for the final forecast
mape_final <- mean(abs(final_forecast_1$mean - test_ts) / abs(test_ts)) * 100
mse_final <- mean((final_forecast_1$mean - test_ts)^2)
cat("Final ARIMAX Forecast -> MAPE:", mape_final, "\nMSE:", mse_final)

checkresiduals(final_forecast_1)
```

